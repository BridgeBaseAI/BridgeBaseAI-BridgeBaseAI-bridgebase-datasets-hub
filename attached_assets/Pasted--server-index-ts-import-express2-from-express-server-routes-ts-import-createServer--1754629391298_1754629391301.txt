// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/storage.ts
import { randomUUID } from "crypto";
var MemStorage = class {
  datasets;
  aiQueries;
  constructor() {
    this.datasets = /* @__PURE__ */ new Map();
    this.aiQueries = /* @__PURE__ */ new Map();
    this.initializeDatasets();
  }
  initializeDatasets() {
    const initialDatasets = [
      {
        id: "defi-tvl-analytics",
        title: "DeFi TVL Analytics",
        description: "Real-time Total Value Locked data across 150+ protocols. Includes Ethereum ($84.1B), Solana ($9.9B), and emerging chains with comprehensive protocol analytics.",
        source: "https://defillama.com/api",
        tags: ["defi", "tvl", "defillama", "protocols"],
        updateFrequency: "hourly",
        volume: "150+ protocols",
        category: "DeFi",
        status: "live",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: "nft-trading-data",
        title: "NFT Trading Data",
        description: "Comprehensive NFT marketplace data with $946M monthly volume. Ethereum dominance at 78.5% with emerging Polygon growth and 9.2M monthly sales.",
        source: "https://dappradar.com/nft",
        tags: ["nft", "trading", "opensea", "polygon"],
        updateFrequency: "daily",
        volume: "9.2M sales/month",
        category: "NFT",
        status: "live",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: "dao-ecosystem",
        title: "DAO Ecosystem Analytics",
        description: "Track 13,000+ DAOs with $40B+ combined treasury value. Governance activity across major protocols and communities with 11M token holders globally.",
        source: "https://www.alchemy.com/dapps/top/daos",
        tags: ["dao", "governance", "treasury", "tokens"],
        updateFrequency: "weekly",
        volume: "11M token holders",
        category: "DAO",
        status: "live",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: "bitcoin-blockchain",
        title: "Bitcoin Blockchain Historical Data",
        description: "Complete historical Bitcoin blockchain data from Kaggle BigQuery. Includes blocks, transactions, and address analytics for comprehensive Bitcoin network analysis.",
        source: "https://www.kaggle.com/datasets/bigquery/bitcoin-blockchain",
        tags: ["bitcoin", "blockchain", "kaggle", "historical"],
        updateFrequency: "quarterly",
        volume: "Full blockchain",
        category: "Blockchain",
        status: "historical",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: "ethereum-defi-protocols",
        title: "Ethereum DeFi Protocols",
        description: "Ethereum ecosystem with 59.7% DeFi market share. Includes Uniswap, Aave, and Lido Finance protocol data with $84.1B total value locked.",
        source: "https://defillama.com/chain/Ethereum",
        tags: ["ethereum", "defi", "uniswap", "aave"],
        updateFrequency: "hourly",
        volume: "$84.1B TVL",
        category: "DeFi",
        status: "live",
        createdAt: /* @__PURE__ */ new Date()
      }
    ];
    initialDatasets.forEach((dataset) => {
      this.datasets.set(dataset.id, dataset);
    });
  }
  async getAllDatasets() {
    return Array.from(this.datasets.values());
  }
  async getDataset(id) {
    return this.datasets.get(id);
  }
  async createDataset(insertDataset) {
    const dataset = {
      ...insertDataset,
      status: insertDataset.status || "live",
      createdAt: /* @__PURE__ */ new Date()
    };
    this.datasets.set(dataset.id, dataset);
    return dataset;
  }
  async createAiQuery(insertQuery) {
    const id = randomUUID();
    const query = {
      id,
      question: insertQuery.question,
      context: insertQuery.context || null,
      answer: "",
      // Will be filled by the AI service
      confidence: null,
      sources: null,
      createdAt: /* @__PURE__ */ new Date()
    };
    this.aiQueries.set(id, query);
    return query;
  }
  async getRecentQueries(limit = 10) {
    const queries = Array.from(this.aiQueries.values()).sort((a, b) => (b.createdAt?.getTime() || 0) - (a.createdAt?.getTime() || 0)).slice(0, limit);
    return queries;
  }
};
var storage = new MemStorage();

// shared/schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var datasets = pgTable("datasets", {
  id: varchar("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  source: text("source").notNull(),
  tags: text("tags").array().notNull(),
  updateFrequency: text("update_frequency").notNull(),
  volume: text("volume").notNull(),
  category: text("category").notNull(),
  status: text("status").notNull().default("live"),
  createdAt: timestamp("created_at").default(sql`now()`)
});
var aiQueries = pgTable("ai_queries", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  question: text("question").notNull(),
  answer: text("answer").notNull(),
  context: text("context"),
  confidence: text("confidence"),
  sources: text("sources").array(),
  createdAt: timestamp("created_at").default(sql`now()`)
});
var insertDatasetSchema = createInsertSchema(datasets).pick({
  id: true,
  title: true,
  description: true,
  source: true,
  tags: true,
  updateFrequency: true,
  volume: true,
  category: true,
  status: true
});
var insertAiQuerySchema = createInsertSchema(aiQueries).pick({
  question: true,
  context: true
});
var aiResponseSchema = z.object({
  answer: z.string(),
  sources: z.array(z.string()).optional(),
  confidence: z.number().optional()
});

// server/routes.ts
import { z as z2 } from "zod";
async function registerRoutes(app2) {
  app2.get("/api/datasets", async (req, res) => {
    try {
      const datasets2 = await storage.getAllDatasets();
      res.json({ datasets: datasets2 });
    } catch (error) {
      console.error("Error fetching datasets:", error);
      res.status(500).json({
        error: "Failed to fetch datasets",
        message: "Unable to retrieve Web3 datasets. Please try again later."
      });
    }
  });
  app2.post("/api/ask", async (req, res) => {
    try {
      const body = insertAiQuerySchema.parse(req.body);
      const query = await storage.createAiQuery(body);
      const openRouterKey = process.env.OPENROUTER_API_KEY || process.env.OPENROUTER_KEY || "";
      if (!openRouterKey) {
        return res.status(500).json({
          error: "API configuration missing",
          message: "OpenRouter API key is not configured. Please check environment variables."
        });
      }
      const openRouterResponse = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${openRouterKey}`,
          "Content-Type": "application/json",
          "HTTP-Referer": process.env.SITE_URL || "http://localhost:5000",
          "X-Title": "BridgeHub Web3 AI Assistant"
        },
        body: JSON.stringify({
          model: "deepseek/deepseek-chat",
          messages: [
            {
              role: "system",
              content: "You are a Web3 and blockchain expert assistant. Provide accurate, helpful information about DeFi protocols, NFT markets, DAO governance, cryptocurrency, and blockchain technology. Use current data when possible and cite sources. Keep responses informative but concise."
            },
            {
              role: "user",
              content: body.question
            }
          ],
          max_tokens: 1e3,
          temperature: 0.7
        })
      });
      if (!openRouterResponse.ok) {
        const errorText = await openRouterResponse.text();
        console.error("OpenRouter API error:", errorText);
        return res.status(500).json({
          error: "AI service unavailable",
          message: "The AI assistant is temporarily unavailable. Please try again later."
        });
      }
      const openRouterData = await openRouterResponse.json();
      const aiAnswer = openRouterData.choices[0]?.message?.content || "I apologize, but I couldn't generate a response. Please try rephrasing your question.";
      query.answer = aiAnswer;
      query.sources = ["OpenRouter DeepSeek API"];
      query.confidence = "0.85";
      res.json({
        answer: aiAnswer,
        sources: query.sources,
        confidence: parseFloat(query.confidence)
      });
    } catch (error) {
      console.error("Error in AI query:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({
          error: "Invalid request format",
          message: "Please provide a valid question in your request.",
          details: error.errors
        });
      }
      res.status(500).json({
        error: "Internal server error",
        message: "An unexpected error occurred while processing your question. Please try again."
      });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();